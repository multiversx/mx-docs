---
id: sc-test setup
title: Test setup
---

[comment]: # "mx-abstract"

## Overview

[comment]: # (mx-context-auto)

If you haven't yet, run the build command for your smart contract while in the contract directory `your-contract/`, that contains all the contract's directories.

```bash
sc-meta all build
```

### Creating test file

Navigate to the folder `tests/` inside the contract's main directory and create a new Rust file to write the code for testing `your-contract/tests/your_contract_test.rs`.

### Generating Proxy

Before creating the test, we need to set up the environment, starting with a Proxy.

A smart contract's proxy is an object that mimics the contract. We will use the proxy to call the endpoints.

The proxy contains entirely autogenerated code. However, before running the command to generate the proxy, we need to set up a configuration file.

In the root of the contract, at the path `your-contract/`, create the configuration file `sc-config.toml`, where we will specify the path to generate the proxy. The file should contain the following code:

```rust title=sc-config.toml
[settings]

[[proxy]]
path = "src/your_contract_proxy.rs"
```

In the terminal, in the root of the contract, we will run the next command that will generate the proxy for your smart contract:


```
sc-meta all proxy
```

Once the proxy is generated, the work is not over yet. The next thing to do is to import the module in your smart contract's code:

```rust title=your_contract.rs
#![no_std]

#[allow(unused_imports)]
use multiversx_sc::imports::*;

pub mod your_contract_proxy;

#[multiversx_sc::contract]
pub trait YourContract {

    //...
}
```

With each build of the contract executed by the developer, the proxy will be automatically updated with the changes made to the contract.

### Registering contracts

Since we don't have native execution in the Rust backend yet, the only way to run contracts is to register the contract implementation for the given contract code identifier. In simpler words, we tell the environment "whenever you encounter this contract code, run this code that I've written instead".

Since this operation is specific to only the Rust debugger, it doesn't go through the mandos pipeline.


[comment]: # (mx-context-auto)

### Setting accounts

Setting accounts in blackbox tests can be easily done by using a `SetStateBuilder`. In order to create an instance of the builder, we have to call the `.account(...)` method from `ScenarioWorld`.

```rust title=blackbox_test.rs
world // ScenarioWorld struct
    .account(USER_ADDRESS) // SetStateBuilder with USER_ADDRESS account
    .nonce(1) // custom nonce
    .balance(50) // egld balance
    .esdt_balance(TRANSFER_TOKEN, 1000) // esdt balance 
    .esdt_nft_balance(NFT_TOKEN_ID, 1u64, 1u64, ManagedBuffer::new()); // nft balance
```

There are no mandatory fields, so we can only add the fields that we actually need. For example, if we only need to create the account and we don't care about other fields, `world.account(ADDRESS)` will compile. 

However, there is no possibility to upgrade and existing account, so there can only be one set block per account.

We can also chain the set state declarations (if useful) as such:

```rust title=blackbox_test.rs
    world
        .account(first) // SetStateBuilder for account `first`
        .nonce(1)
        .balance(100) 
        .account(second) // SetStateBuilder for `second`, ends set state for `first`
        .nonce(2)
        .balance(300)
        .esdt_balance(TOKEN_ID, 500); // end set state for `second`
```

[comment]: # (mx-context-auto)

### Checking accounts

Similar to setting accounts, the framework provides a `CheckStateBuilder` that we can use to check state values. The check builder is instantiated using `.check_account(...)` from `ScenarioWorld`.

```rust title=blackbox_test.rs
    world
        .check_account(first) // CheckStateBuilder for `first`
        .nonce(3)
        .balance(100);
```

The same rules apply when chaining multiple account checks as for chaining accounts set.

```rust title=blackbox_test.rs
    world
        .check_account(first) // CheckStateBuilder for `first`
        .nonce(3)
        .balance(100);
        .check_account(second) // CheckStateBuilder for `second`, ends check state for `first`
        .check_storage("str:sum", "6");
```

[comment]: # (mx-context-auto)

### Mandos trace

A mandos [trace](../rust/mandos-trace) can quickly be generated by wrapping the integration test logic into the trace generation as such:

```rust title=blackbox_test.rs
    world.start_trace();

    // integration test logic

    world.write_scenario_trace("trace1.scen.json");
```